Отчет о восстановлении сервера
Цель проекта
Целью проекта было подключиться к серверу, восстановить его работоспособность и устранить причины, по которым веб-сервис перестал работать. Известно, что на сервере настроены резервные копии.

Процесс работы
1. Проверка доступности сайта
Первоначально была получена ссылка на сайт: http://3.68.118.16/ (Мы используем IP-адрес вместо имени домена для тестирования и настройки, чтобы избежать проблем с DNS. При попытке доступа к сайту выяснилось, что он не работает.

2. Подключение к серверу
Подключение к серверу было осуществлено через SSH:
ssh ec2-user@3.68.118.16 
где
ssh: Утилита для подключения к удаленным серверам с использованием протокола SSH (Secure Shell)
ec2-user@3.68.118.16: Указание имени пользователя (ec2-user) и адреса сервера (3.68.118.16)
для успешного подключения по SSH  публичный ключ должен быть добавлен в файл ~/.ssh/authorized_keys на удаленном сервере. Либо доступ по паролю.

3. Проверка статуса веб-сервера
sudo service httpd status
sudo -  позволяет пользователю выполнять команды с привилегиями суперпользователя (root)
service - Команда для управления службами
httpd - имя службы веб-сервера Apache
status - указывает команде service проверить текущий статус указанной службы, в данной команде указывает на httpd

получили ответ что недостаточно места.

4. Проверка наличия свободного места на диске
Проверили свободное пространство на диске:
df -h
df выводит информацию о файловых системах
-h выводит размеры в удобном для чтения формате
в результате обнаружили что раздел полностью занят.

5. Поиск больших файлов
Для освобождения места обнаружили файлы, занимающие много пространства:

find / -type f -size +100M -exec du -h {} +
find / - ищет файлы и каталоги в указанном пути. В данном случае / означает, что поиск будет выполнен по всей файловой системе, начиная с корневого каталога.
-type f - указывает find искать только файлы ( имеется ввиду, что каталоги будут исключены из поиска)
-size +100M - ищет файлы, размер которых превышает 100 мегабайт. Важный момент не забывать перед размером ставить знак, т.к. без знака будет поиск конкретного значения ( имеется ввиду в данном случае без знака + поиск осуществлялся бы ровно 100 мб)
-exec du -h {} + параметр указывает, что для каждого найденного файла будет выполнена команда du -h

Результат показал, что файл журнала /var/log/httpd/access_log занимает основное место.

6. Очистка журнала
Чтобы освободить место, очистили файл журнала:

sudo echo "" > /var/log/httpd/access_log

sudo - команда позволяет выполнять команды с привилегиями суперпользователя (root).
echo - выводит строку в консоль. В данном случае echo "" выводит пустую строку.
> - оператор перенаправления, который перезаписывает содержимое файла. Он направляет вывод команды echo "" в указанный файл. команжа эхо выводит пустую строку, соотвественно содержимое файла будет заменено на эту пустую строку.
/var/log/httpd/access_log - путь к файлу журнала веб-сервера Apache. В этот файл записываются все запросы к веб-серверу.

также были обнаружены заархивированные бекапы логов их также удаляем.
sudo find /var/log/httpd/ -name "*.gz" -type f -delete
find - Ищет файлы и каталоги в указанном пути
/var/log/httpd/ - Путь к директории, в которой будет происходить поиск.
-name "*.gz": Ищет файлы с расширением .gz (архивы).
-type f: Ограничивает поиск только файлами.
-delete: Удаляет найденные файлы.
потерпели неудачу и пришлось вручную удалять каждый архив ( ссылаясь на имя каждого, что было удивительно, т.к. линукс не ругнулся на предыдущие действия)…

7. Восстановление файла конфигурации
LocalSettings\ \(5\).php
данный файл оказался не корректным ( пустым)
в той же директории нашли файл конфигурации. Важно открывали его через cat, чтобы случайно его не отредактировать и сломать. Перед редактированием, желательно файл дополнительно сохранить, чтобы не потерять. Затем открыли файл через редактор, нано. Увидели что в нем указана неправильная конфигурация: $wgServer = "https://18.153.51.162"; Эту строку нужно было заменить на актуальный адрес сервера.

скопировали файл конфигурации приложения:
cp /home/ec2-user/LocalSettings\ \(5\).php /var/www/html/mediawiki/LocalSettings.php

cp команда используется для копирования файлов и каталогов
/home/ec2-user/LocalSettings\ \(5\).php: Это путь к исходному файлу
/home/ec2-user/: Директория, в которой находится исходный файл
LocalSettings\ \(5\).php: Имя файла, который будет скопирован
/var/www/html/mediawiki/LocalSettings.php: Это путь к целевому файлу, в который будет скопирован исходный файл
/var/www/html/mediawiki/: Директория, куда файл будет скопирован.
LocalSettings.php: Имя нашего файла.

8. Проверили сайт, все работает. Желательно, открывать с отключением кеша, т.к.  веб-приложение или веб-сервер используют кеширование охраняют копию файла или данных, чтобы ускорить доступ к ним и уменьшить нагрузку на сервер. а это значит, мы могли сделать изменения, но при обновлении странички не увидеть изменений. можем отключить кеш от всей текущей сессии Ctrl + Shift + I . вкладка Network. включить Disable cache. обновить страничку.

9. Настройка автоматической ротации логов

Для настройки автоматической ротации логов  создадим скрипт. /home/ec2-user/backup_logs.sh, который будет архивировать логи и удалять старые архивы.

1 nano /home/ec2-user/backup_logs.sh 
открываем текстовый редакторв нано по директории  /home/ec2-user/ с названием backup_logs.sh 

#!/bin/bash

# Путь к директории, содержащей логи
LOG_DIR="/var/log/httpd"
# Имя файла журнала для архивирования
LOG_FILE="access_log"
# Путь к директории для хранения архивов
BACKUP_DIR="/home/ec2-user/log_backups"
# Максимальное количество архивов для хранения
MAX_BACKUPS=3
# Текущая дата в формате ГГГГММДД
DATE=$(date +%Y%m%d)
# Имя архива с текущей датой
ARCHIVE="$BACKUP_DIR/$LOG_FILE-$DATE.tar.gz"

# Создание директории для хранения архивов, если её нет
mkdir -p "$BACKUP_DIR"

# Архивируем файл журнала
tar -czf "$ARCHIVE" "$LOG_DIR/$LOG_FILE"

# Удаляем старые архивы, оставляя только последние $MAX_BACKUPS архивов
find "$BACKUP_DIR" -type f -name "$LOG_FILE-*.tar.gz" -mtime +$((MAX_BACKUPS - 1)) -exec rm {} \;

# Сообщение о завершении работы скрипта
echo "Логи архивированы и старые архивы удалены."



детаельно описываю скрипт

#!/bin/bash - шебанг указывает что скрипт должен выполняться с помощью интерпретатора Bash

LOG_DIR="/var/log/httpd" - Устанавливает переменную LOG_DIR с путем к директории, где хранятся лог-файлы. В этом случае это директория /var/log/httpd, содержащая логи веб-сервера Apache.

LOG_FILE="access_log": Устанавливает переменную LOG_FILE с именем файла лога, который нужно архивировать. В данном случае это access_log

BACKUP_DIR="/home/ec2-user/log_backups": Устанавливает переменную BACKUP_DIR с путем к директории, в которую будут сохраняться архивы логов. В этом случае это директория /home/ec2-user/log_backups

MAX_BACKUPS=3: Устанавливает переменную MAX_BACKUPS с максимальным количеством архивов, которое нужно хранить. В данном случае это 3 архива.

DATE=$(date +%Y%m%d): Устанавливает переменную DATE с текущей датой в формате ГГГГММДД. Команда date +%Y%m%d возвращает текущую дату, форматированную как год, месяц и день.
ARCHIVE="$BACKUP_DIR/$LOG_FILE-$DATE.tar.gz": Устанавливает переменную ARCHIVE с полным путем и именем файла архива. Этот файл будет содержать архивированный лог-файл с текущей датой в имени и расширением .tar.gz
mkdir -p "$BACKUP_DIR": Создает директорию для хранения архивов, если её не существует. Параметр -p позволяет создать все необходимые промежуточные директории, если они отсутствуют.
tar -czf "$ARCHIVE" "$LOG_DIR/$LOG_FILE": Создает архив с помощью утилиты tar. со следуующми параметрами
-c: Создает новый архив.
-z: Сжимает архив с помощью gzip.
-f: Указывает имя файла архива.
$ARCHIVE: Имя создаваемого архива.
$LOG_DIR/$LOG_FILE: Путь к исходному файлу лога, который будет включен в архив.


find "$BACKUP_DIR" -type f -name "$LOG_FILE-*.tar.gz" -mtime +$((MAX_BACKUPS - 1)) -exec rm {} \;: Находит и удаляет старые архивы, оставляя только последние $MAX_BACKUPS архивов. имеет следующие параметры:

find $BACKUP_DIR: Запускает поиск в директории архивов.
-type f: Ищет только файлы (но не директории).
-name $LOG_FILE-*.tar.gz: Находит файлы, соответствующие шаблону имени.
-mtime +$((MAX_BACKUPS - 1)): Находит файлы, которые были изменены более $((MAX_BACKUPS - 1)) дней назад. Это оставляет только последние $MAX_BACKUPS архивов.
-exec rm {} \;: Для каждого найденного файла выполняет команду rm (удаление). {} представляет найденный файл.


если в кратце суть нашего скрипта обеспечить автоматическое создание архивов логов и управлять количеством хранимых архивов, предотвращая заполнение диска старыми файлами.


chmod +x /home/ec2-user/backup_logs.sh

chmod -  команда, которая используется для изменения прав доступа к файлам и каталогам
+x -  флаг, который добавляет право на выполнение (execute) для файлаю Этот флаг добавляет право на выполнение для владельца файла, группы и всех остальных пользователей, если они ранее не имели этого права.
/home/ec2-user/backup_logs.sh: Это путь к файлу для которого меняются права

дальше настраиваем задачу в cron для ежедневного выполнения:

crontab -e

crontab - команда для управления таблицей задач cron
-e - флаг, который указывает на то, что хотим отредактировать таблицу cron

в кроне прописываем

0 0 * * * /home/ec2-user/backup_logs.sh

будет автоматически запускаться каждый день в 00:00


Итоги
1Перезапуск веб-сервиса: Apache был успешно перезапущен.
2 Очистка дискового пространства: Освобожденное пространство позволило серверу функционировать нормально.
3 Восстановление конфигурационного файла: Файл настроек был успешно скопирован и обновлен.
4 Настройка ротации логов: Создан скрипт и настроен cron для автоматического архивирования логов и предотвращения их переполнения.
5 Сервер был успешно восстановлен, и веб-приложение теперь работает корректно. Ротация логов настроена для предотвращения подобных проблем в будущем.

Рекомендации и предложения по улучшению процессов:

1 Мониторинг ресурсов: Внедрить систему мониторинга для отслеживания использования дискового пространства и других ресурсов в реальном времени.  что значительтно поможет своевременному реагированию на возможные проблемы
2 Регулярное резервное копирование: Обеспечить регулярное создание резервных копий всех критичных данных и конфигурационных файлов, чтобы избежать потерь при возникновении непредвиденных проблем.
3 Документирование и обучение: Обеспечить наличие документации по управлению сервером и процессами восстановления, а также проводить обучение для персонала по актуальным методам и инструментам. Таким образом сотрудники в любой момент смогут быстро и самостоятельно решать проблемы.

